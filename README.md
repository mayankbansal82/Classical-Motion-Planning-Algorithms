# Classical-Motion-Planning-Algorithms

This repository contains implementations of various classical path planning algorithms for autonomous agents such as robots or self-driving cars. The algorithms include:
- Breadth-first search based path finding
- Depth-first search based path finding
- A* algorithm
- Dijkstra's algorithm

### Prerequisites
The code is written in Python and requires the following packages:
- Numpy
- Matplotlib
- csv 

### Usage
To run an algorithm, simply navigate to the relevant folder and run the main.py python file. For example, to run the A* and Dijkstra's implementations, navigate to the Astar, Dijkstra Algorithm Implementation folder and run main.py in your terminal or command prompt. The algorithms itself are implemented in the search.py file and main.py generates the grid and start and end points based on map.csv. You can alter the map and the start and end points according to your needs.

**Note:** The order of exploration is right, down, left, up.

**Note:** Manhattan distance is used as the heuristic for A*.

The demo visualizes the path generated by the algorithm, as well as the number of steps the specific algorithm took, i.e. the number of nodes visited to generate the final path.

### Algorithms in detail

#### Breadth-first search
Breadth-first search (BFS) is a graph search algorithm used for finding the shortest path between two vertices in an unweighted graph. It starts at the source vertex and explores all its neighbors before moving on to the neighbors' neighbors and so on. The algorithm uses a queue to keep track of the vertices to be explored, where each vertex is added to the queue as soon as it is discovered. BFS is guaranteed to find the shortest path between two vertices as it visits all vertices at a given depth level before moving on to the next.

#### Depth-first search
Depth-first search (DFS) is a graph search algorithm used for finding a path between two vertices in a graph. It starts at the source vertex and explores as far as possible along each branch before backtracking. The algorithm uses a stack to keep track of the vertices to be explored, where each vertex is added to the stack as soon as it is discovered. DFS may not necessarily find the shortest path between two vertices, as it prioritizes exploring deeper into the graph before backtracking and visiting other vertices at shallower levels.

#### Djikstra's algorithm
Dijkstra's algorithm is a classic graph search algorithm that finds the shortest path from a start node to a goal node in a weighted graph. The algorithm maintains a priority queue of nodes to be expanded, where the priority is given by the current cost to reach that node. At each step, the node with the lowest cost is expanded and its neighbors are added to the queue, updating their cost if necessary. The algorithm terminates when the goal node is reached.

#### A* algorithm
A* is a best-first search algorithm that finds the shortest path from a start node to a goal node in a weighted graph. Like Dijkstra's, A* maintains a priority queue of nodes to be expanded, but with an additional heuristic that estimates the cost to reach the goal node from each node. The priority of each node is given by the sum of the current cost and the heuristic cost, encouraging the algorithm to prioritize nodes that are likely to lead to the goal.

### Results

#### BFS and DFS

![alt text](https://github.com/mayankbansal82/Classical-Motion-Planning-Algorithms/blob/main/images/BFSDFS1.png)
The number of steps taken by BFS is 64 while DFS takes 33 steps to find the final path.

![alt text](https://github.com/mayankbansal82/Classical-Motion-Planning-Algorithms/blob/main/images/BFSDFS2.png)
The number of steps taken by BFS is 34 while DFS takes 51 steps to find the final path.

#### Djikstra's and A*

![alt text](https://github.com/mayankbansal82/Classical-Motion-Planning-Algorithms/blob/main/images/AD1.png)
The number of steps taken by Djikstra's is 64 while A* takes 51 steps to find the final path.

![alt text](https://github.com/mayankbansal82/Classical-Motion-Planning-Algorithms/blob/main/images/AD2.png)
The number of steps taken by Djikstra's is 45 while A* takes 15 steps to find the final path.




